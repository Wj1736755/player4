package org.fossify.musicplayer.helpers

import android.content.Context
import android.media.MediaMetadataRetriever
import android.media.MediaMetadataRetriever.*
import android.provider.MediaStore
import android.util.Log
import org.fossify.commons.extensions.getFilenameFromPath
import org.fossify.musicplayer.models.Track
import org.fossify.musicplayer.models.TXXXTags
import java.io.File
import java.io.FileInputStream
import java.util.UUID

/**
 * Factory class for creating Track objects from MP3 files
 * with full metadata and TXXX tags support
 */
class TrackFactory(private val context: Context) {
    
    /**
     * Create Track from MP3 file with all metadata and TXXX tags.
     * 
     * This method reads:
     * - Basic metadata from MediaMetadataRetriever (title, artist, album, duration, etc.)
     * - Custom TXXX tags from TXXXTagsReader (transcription, guid, checksum, etc.)
     * 
     * @param file MP3 file to read
     * @param mediaStoreId MediaStore ID (0 if not in MediaStore yet)
     * @param playlistId Playlist ID to assign (default 0)
     * @return Track object or null if file cannot be read
     */
    fun createTrackFromFile(
        file: File,
        mediaStoreId: Long = 0,
        playlistId: Int = 0
    ): Track? {
        if (!file.exists() || !file.canRead()) {
            Log.e(TAG, "File does not exist or cannot be read: ${file.absolutePath}")
            return null
        }
        
        return try {
            // 1. Read basic metadata using MediaMetadataRetriever
            val metadata = readBasicMetadata(file)
            
            // 2. Read custom TXXX tags from file
            val tags: TXXXTags = try {
                TXXXTagsReader.readAllTags(file) ?: TXXXTags()
            } catch (e: Exception) {
                Log.w(TAG, "Failed to read TXXX tags from file: ${file.name}", e)
                TXXXTags()  // Empty tags
            }
            
            // 3. Calculate checksum if not present in tags
            val checksum: String? = tags.checksumAudio ?: try {
                MD5AudioCalculator.calculate(file)
            } catch (e: Exception) {
                Log.w(TAG, "Failed to calculate checksum for file: ${file.name}", e)
                null
            }
            
            // 4. Flags (no special flags needed - all tracks are in MediaStore)
            val flags = 0
            
            // 5. Get folder name
            val folderName = file.parentFile?.name ?: ""
            
            // 6. Get date added
            val addedAtTimestampUnix = try {
                (file.lastModified() / 1000L).toInt()
            } catch (e: Exception) {
                (System.currentTimeMillis() / 1000L).toInt()
            }
            
            // 7. Create Track
            Track(
                id = 0,  // Auto-generated by Room
                mediaStoreId = mediaStoreId,
                title = metadata.title,
                artist = metadata.artist,
                path = file.absolutePath,
                duration = metadata.duration,
                album = metadata.album,
                genre = metadata.genre,
                coverArt = "",  // Will be set by audioHelper if needed
                trackId = metadata.trackNumber,
                discNumber = metadata.discNumber,
                folderName = folderName,
                albumId = 0,  // Will be resolved by audioHelper
                artistId = 0, // Will be resolved by audioHelper
                genreId = 0,  // Will be resolved by audioHelper
                year = metadata.year,
                addedAtTimestampUnix = addedAtTimestampUnix,
                flags = flags,
                // Custom TXXX tags from file
                transcription = tags.transcription,
                transcriptionNormalized = tags.transcription?.let { ID3TagsHelper.normalizeText(it) },
                guid = tags.guid?.let { UUID.fromString(it) },
                tagTxxxCreatedAtUnix = tags.createdOnTimestamp,
                checksumAudio = checksum
            )
        } catch (e: Exception) {
            Log.e(TAG, "Error creating Track from file: ${file.absolutePath}", e)
            null
        }
    }
    
    /**
     * Read basic metadata from MP3 file using MediaMetadataRetriever
     */
    private fun readBasicMetadata(file: File): BasicMetadata {
        val retriever = MediaMetadataRetriever()
        var inputStream: FileInputStream? = null
        
        try {
            try {
                retriever.setDataSource(file.absolutePath)
            } catch (e: Exception) {
                // Fallback: try with FileInputStream
                inputStream = FileInputStream(file)
                retriever.setDataSource(inputStream.fd)
            }
            
            val title = retriever.extractMetadata(METADATA_KEY_TITLE)
                ?: file.nameWithoutExtension
            
            val artist = retriever.extractMetadata(METADATA_KEY_ARTIST)
                ?: retriever.extractMetadata(METADATA_KEY_ALBUMARTIST)
                ?: MediaStore.UNKNOWN_STRING
            
            val album = retriever.extractMetadata(METADATA_KEY_ALBUM)
                ?: file.parentFile?.name
                ?: MediaStore.UNKNOWN_STRING
            
            val durationMs = retriever.extractMetadata(METADATA_KEY_DURATION)
                ?.toLongOrNull() ?: 0L
            val duration = (durationMs / 1000).toInt()
            
            val genre = retriever.extractMetadata(METADATA_KEY_GENRE)
                ?.trim()
                ?.takeIf { it.isNotEmpty() }
                ?: ""
            
            val year = retriever.extractMetadata(METADATA_KEY_YEAR)
                ?.toIntOrNull() ?: 0
            
            val trackNumber = retriever.extractMetadata(METADATA_KEY_CD_TRACK_NUMBER)
                ?.split("/")?.firstOrNull()
                ?.toIntOrNull()
            
            val discNumber = retriever.extractMetadata(METADATA_KEY_DISC_NUMBER)
                ?.split("/")?.firstOrNull()
                ?.toIntOrNull()
            
            return BasicMetadata(
                title = title,
                artist = artist,
                album = album,
                duration = duration,
                genre = genre,
                year = year,
                trackNumber = trackNumber,
                discNumber = discNumber
            )
        } finally {
            try {
                inputStream?.close()
                retriever.release()
            } catch (ignored: Exception) {
            }
        }
    }
    
    /**
     * Create Track from MediaStore ID and pre-read TXXX tags.
     * 
     * This is useful when tags have already been read from file and we want to avoid
     * reading them again. Queries MediaStore to get file path and metadata.
     * 
     * @param mediaStoreId MediaStore ID of the file
     * @param tags Pre-read TXXX tags
     * @return Track object or null if MediaStore entry not found
     */
    fun createFromMediaStoreId(
        mediaStoreId: Long,
        tags: TXXXTags
    ): Track? {
        // Query MediaStore to get file path
        val uri = android.content.ContentUris.withAppendedId(
            android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
            mediaStoreId
        )
        
        val projection = arrayOf(
            android.provider.MediaStore.Audio.Media.DATA
        )
        
        var filePath: String? = null
        try {
            context.contentResolver.query(uri, projection, null, null, null)?.use { cursor ->
                if (cursor.moveToFirst()) {
                    filePath = cursor.getString(0)
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error querying MediaStore for ID $mediaStoreId", e)
            return null
        }
        
        if (filePath == null) {
            Log.e(TAG, "File path not found in MediaStore for ID $mediaStoreId")
            return null
        }
        
        val file = File(filePath)
        if (!file.exists()) {
            Log.e(TAG, "File does not exist: $filePath")
            return null
        }
        
        // Read basic metadata
        val metadata = readBasicMetadata(file)
        
        // Calculate checksum if not present in tags
        val checksum: String? = tags.checksumAudio ?: try {
            MD5AudioCalculator.calculate(file)
        } catch (e: Exception) {
            Log.w(TAG, "Failed to calculate checksum for file: ${file.name}", e)
            null
        }
        
        // Flags
        val flags = 0
        
        // Get folder name
        val folderName = file.parentFile?.name ?: ""
        
        // Get date added
        val addedAtTimestampUnix = try {
            (file.lastModified() / 1000L).toInt()
        } catch (e: Exception) {
            (System.currentTimeMillis() / 1000L).toInt()
        }
        
        // Create Track
        return Track(
            id = 0,
            mediaStoreId = mediaStoreId,
            title = metadata.title,
            artist = metadata.artist,
            path = file.absolutePath,
            duration = metadata.duration,
            album = metadata.album,
            genre = metadata.genre,
            coverArt = "",
            trackId = metadata.trackNumber,
            discNumber = metadata.discNumber,
            folderName = folderName,
            albumId = 0,
            artistId = 0,
            genreId = 0,
            year = metadata.year,
            addedAtTimestampUnix = addedAtTimestampUnix,
            flags = flags,
            // Custom TXXX tags (pre-read)
            transcription = tags.transcription,
            transcriptionNormalized = tags.transcription?.let { ID3TagsHelper.normalizeText(it) },
            guid = tags.guid?.let { UUID.fromString(it) },
            tagTxxxCreatedAtUnix = tags.createdOnTimestamp,
            checksumAudio = checksum
        )
    }
    
    /**
     * Basic metadata from MediaMetadataRetriever
     */
    private data class BasicMetadata(
        val title: String,
        val artist: String,
        val album: String,
        val duration: Int,
        val genre: String,
        val year: Int,
        val trackNumber: Int?,
        val discNumber: Int?
    )
    
    companion object {
        private const val TAG = "TrackFactory"
    }
}
